<?php
namespace IndexTrade;
 
error_reporting(E_ERROR | E_WARNING | E_PARSE);
date_default_timezone_set('UTC');
clearstatcache(true);

include_once( __DIR__ . '/__bootstrap.php');

$log = initLog('idxtTradingApp');

use \Psr\Http\Message\ServerRequestInterface as Request;
use \Psr\Http\Message\ResponseInterface as Response;
use Centrifugo\Centrifugo;
use Ramsey\Uuid;

/**
echo "\n\n";
echo "     ---| IndexTrade.Exchange Platform via CoinIndex Team with LOVE |--- \n\n";
echo "Starting at: " . date('r') . "\n";
echo "Starting ExecutionReports Master...\n\n";
**/

$container = new \Slim\Container;


$container['redis'] = function ($container) {
    return initRedis();
};

$container['ssdb'] = function ($container) {
    return initSSDB();
};

$container['db'] = function ($container) {
    return initDB();
};


//$container['settings'] = Array('displayErrorDetails' => true);

$app = new \Slim\App($container);

$app->get('/hello', function (Request $request, Response $response, array $args) {
    $redis = $this->get('redis');
	$books = $redis->hgetall('INDEXTRDADE_MARKET_VIEW');
	//var_dump( $redis ); exit();
	
	$resp = $response->withJson($books, 200);
	//getBody()->write( $redis->info() );

    return $resp;
});




//создание ордера 
$app->post('/orders/new', function (Request $request, Response $response, array $args) {
    if ($request->getOriginalMethod() !== 'POST'){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid method', 'data' => null), 200);
	}
	
	$quote = $request->getParsedBody();
	$uid = 42;
	
	if (empty($quote)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid body', 'data' => null), 200);
	}
	
	if (is_numeric($quote['price']) && is_numeric($quote['amount']) && is_string($quote['side']) && is_string($quote['symbol'])){
		
		if (!in_array($quote['side'], Array('BUY', 'SELL'))){
			return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid quote type', 'data' => $quote), 200);
		}
		
		//ну, пробуем создать ордер, зафиксировать его а дальше уже разбереться движок 
		$order = Array(
			'id'	=> \Ramsey\Uuid\Uuid::uuid4()->toString(),
			'uid' 	=> $uid,
			'pair' 	=> $quote['symbol'],
			'type'	=> 'LIMIT',
			'side'	=> $quote['side'],
			'exec' 	=> 'GTC',
			'price' => floatval($quote['price']) * 1000000000,
			'amount' => floatval($quote['amount']) * 1000000000,
			'tags'	=> Array(),
			'ts' => t()
		);
		
		$command = Array(
			'act' 	=> 'ADD',
			'body'	=> $order
		);
		
		$redis = $this->get('redis');
		$redis->rpush( 'INDEXTRDADE_NEW_ORDERS_CH0',  json_encode($command));
		
		//отправим репорт, что приняли 
		$ssdb = $this->get('ssdb');
		$report = Array('type' => 'PROPOSED', 'msg' => 'Order sended to API front-end', 'orderID' => $order['id'], 'raw' => $order, 'ts' => t());
		$ssdb->qpush_back('INDEXTRDADE_EXECUTION_REPORTS', json_encode($report));
				
		return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => Array('orderID' => $order['id'])), 200);
	}
	else {
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid quote field type', 'data' => null), 200);
	}
});

//отмена моего ордера 
$app->post('/orders/cancel', function (Request $request, Response $response, array $args) {
    if ($request->getOriginalMethod() !== 'POST'){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid method', 'data' => null), 200);
	}
	
	$order = $request->getParsedBody();
	
	$uid = 42;
	$pair = $order['pair'];
	$oid = $order['orderID'];
	
	//@todo отменят только свои ордера, проверять юзера 
	
	if (empty($order)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid body', 'data' => null), 200);
	}
	
	$ssdb 	= $this->get('ssdb');
	$xx 	= $ssdb->hget('INDEXTRDADE_LIVE_ORDERS_'.$pair, $oid);
	
	if (empty($xx)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid order', 'data' => null), 200);
	}
	
	$baseOrder = json_decode( $xx, true );
	
	if ($baseOrder['id'] != $oid){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid order id', 'data' => null), 200);
	}
	
	//проверить UID 
	
	$command = Array(
		'act' 	=> 'REM',
		'body'	=> $baseOrder
	);
		
	$redis = $this->get('redis');
	$redis->rpush( 'INDEXTRDADE_NEW_ORDERS_CH0',  json_encode($command));
		
	//отправим репорт, что приняли 
	//$ssdb = $this->get('ssdb');
	//$report = Array('type' => 'PROPOSED', 'msg' => 'Order sended to API front-end', 'orderID' => $order['id'], 'raw' => $order, 'ts' => t());
	//$ssdb->qpush_back('INDEXTRDADE_EXECUTION_REPORTS', json_encode($report));
				
	return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => Array('orderID' => $oid)), 200);
	


    return $response;
});

//даг
$app->get('/debug/orders/live', function (Request $request, Response $response, array $args) {
	$ssdb 	= $this->get('ssdb');
	$pair = 'XXX/USDT';
	$xx 	= $ssdb->hkeys('INDEXTRDADE_LIVE_ORDERS_'.$pair, '', '', 100);
	
	return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => $xx), 200);
});


//возвращает текущий маркет-вью по инструменту 
$app->get('/market/overview', function (Request $request, Response $response, array $args) {
    $symbol = $request->getQueryParam('symbol', null);
	
	if (empty($symbol)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid symbol', 'data' => null), 200);
	}
	
	$symbol = strtoupper( $symbol );

	$redis = $this->get('redis');
	$mview = $redis->hget('INDEXTRDADE_MARKET_VIEW', $symbol);
	
	if (!empty($mview)){
		$mview = json_decode( $mview, true, 16 );
		
		return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => $mview), 200);
	}
	else
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid market overview', 'data' => null), 200);
});

//получить список последних активных ордеров юзера 
$app->get('/user/orders/last', function (Request $request, Response $response, array $args) {
    $symbol = $request->getQueryParam('symbol', null);
	
	if (empty($symbol)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid symbol', 'data' => null), 200);
	}
	
	$symbol = strtoupper( $symbol );
	$limit = 10;
	$db = $this->get('db');
	
	//$ssdb = $this->get('ssdb');
	//$z = $ssdb->hkeys('INDEXTRDADE_LIVE_ORDERS_' . $symbol, '', '', 99999);
	
	$p_id = $db->fetchOne('SELECT _id FROM exchange_pairs_tbl WHERE pair_name = "'.$symbol.'" LIMIT 1');
	$uid = 1;
	
	$res = $db->fetchAll('SELECT order_uuid AS orderID, order_type, order_side, order_exec, order_datetime, order_price, order_amount, order_fee, order_status, order_partial_filled FROM exchange_real_orders_tbl WHERE order_uid = ? AND order_status = "live" AND order_pair_id = ? ORDER BY order_datetime DESC LIMIT ' . $limit, Array($uid, $p_id));
	
	$orders = Array();
	
	foreach($res as $x){
		//if (!in_array($x['orderID'], $z))
		//	continue;
		
		
		if (!empty($x['order_partial_filled']))
			$x['order_amount'] = $x['order_amount'] - $x['order_partial_filled'];
				
		$x['order_price'] = round( $x['order_price'] / 1000000000, 6 );
		$x['order_amount'] = round( $x['order_amount'] / 1000000000, 6 );
		$x['order_fee'] = round( $x['order_fee'] / 1000000000, 6 );
		
		$x['order_total'] = round( $x['order_price'] * $x['order_amount'], 6 );
		
		$orders[] = $x;
	}
	
	if (!empty($orders)){
		return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => $orders), 200);
	}
	else
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Error while orders fetch', 'data' => null), 200);
});

//позиция по инструменту 
$app->get('/user/position', function (Request $request, Response $response, array $args) {
    $symbol = $request->getQueryParam('symbol', null);
	
	if (empty($symbol)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid symbol', 'data' => null), 200);
	}
	
	$symbol = strtoupper( $symbol );
	$uid = 1;
	$db = $this->get('db');
	
	$sql = 'SELECT pair_name, pair_asset, pair_currency FROM exchange_pairs_tbl WHERE pair_name = ? AND pair_status = "traded" LIMIT 1';
	
	$p = $db->fetchRow($sql, Array($symbol));
	
	if (empty($p)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid trading pair', 'data' => null), 200);
	}
	
	$sql = 'SELECT currency_symbol, currency_balance, amount_at_orders, amount_at_guarantee, amount_at_pending_withdraw FROM exchange_users_balances_tbl WHERE uid = ? AND currency_symbol = ? ';
	
	$asset = $db->fetchRow( $sql, Array($uid, $p['pair_asset']));
	$currency = $db->fetchRow( $sql, Array($uid, $p['pair_currency']));
	
	if (!empty($asset['currency_balance']))
		$asset['currency_balance'] = round($asset['currency_balance'] / 1000000000, 6);
	
	if (!empty($asset['amount_at_orders']))
		$asset['amount_at_orders'] = round($asset['amount_at_orders'] / 1000000000, 6);
	
	if (!empty($asset['amount_at_guarantee']))
		$asset['amount_at_guarantee'] = round($asset['amount_at_guarantee'] / 1000000000, 6);
	
	if (!empty($asset['amount_at_pending_withdraw']))
		$asset['amount_at_pending_withdraw'] = round($asset['amount_at_pending_withdraw'] / 1000000000, 6);
	
	
	if (!empty($currency['currency_balance']))
		$currency['currency_balance'] = round($currency['currency_balance'] / 1000000000, 6);
	
	if (!empty($currency['amount_at_orders']))
		$currency['amount_at_orders'] = round($currency['amount_at_orders'] / 1000000000, 6);
	
	if (!empty($currency['amount_at_guarantee']))
		$currency['amount_at_guarantee'] = round($currency['amount_at_guarantee'] / 1000000000, 6);
	
	if (!empty($currency['amount_at_pending_withdraw']))
		$currency['amount_at_pending_withdraw'] = round($currency['amount_at_pending_withdraw'] / 1000000000, 6);
	
	
	
	return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => Array('asset' => $asset, 'currency' => $currency)), 200);	
});

//позиция по инструменту 
$app->get('/user/balance', function (Request $request, Response $response, array $args) {
    $symbol = $request->getQueryParam('symbol', null);
	
	if (empty($symbol)){
		return $response->withJson(Array('status' => 'ERROR', 'error' => 'Invalid symbol', 'data' => null), 200);
	}
	
	$symbol = strtoupper( $symbol );
	$uid = 1;
	$db = $this->get('db');
	
	$sql = 'SELECT currency_symbol, currency_balance, currency_type, amount_at_orders, amount_at_guarantee, amount_at_pending_withdraw FROM exchange_users_balances_tbl WHERE uid = ? AND currency_symbol = ? ';
	
	$currency = $db->fetchRow( $sql, Array($uid, $symbol));
	
	if (!empty($currency['currency_balance']))
		$currency['currency_balance'] = round($currency['currency_balance'] / 1000000000, 6);
	
	if (!empty($currency['amount_at_orders']))
		$currency['amount_at_orders'] = round($currency['amount_at_orders'] / 1000000000, 6);
	
	if (!empty($currency['amount_at_guarantee']))
		$currency['amount_at_guarantee'] = round($currency['amount_at_guarantee'] / 1000000000, 6);
	
	if (!empty($currency['amount_at_pending_withdraw']))
		$currency['amount_at_pending_withdraw'] = round($currency['amount_at_pending_withdraw'] / 1000000000, 6);
		
	//индикативный рейт
	$currency['indicativeUSDRate'] = 1.0123;
	
	$currency['indicativeTotalAmount'] = $currency['currency_balance'] + $currency['amount_at_orders'] + $currency['amount_at_guarantee'] + $currency['amount_at_pending_withdraw'];

	$currency['indicativeUSDBalance'] = round($currency['indicativeUSDRate'] * $currency['indicativeTotalAmount'], 2);
	
	
	return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => $currency), 200);	
});

//быстрые глобальные балансы юзера по всем кошелькам 
$app->get('/user/wallets', function (Request $request, Response $response, array $args) {
    $uid = 1;
	$db = $this->get('db');
	
	$sql = 'SELECT currency_symbol, currency_balance, currency_type FROM exchange_users_balances_tbl WHERE uid = ? AND balance_status = "full_operated" ';
	
	$res = $db->fetchAll( $sql, Array($uid));
	$currency = Array();
	
	foreach($res as $x){
		if (!empty($x['currency_balance']))
			$x['currency_balance'] = round($x['currency_balance'] / 1000000000, 3);
			
			
		$currency[] = $x;
	}
	
	return $response->withJson(Array('status' => 'OK', 'error' => null, 'data' => $currency), 200);	
});


$app->run();

